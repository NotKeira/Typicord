/**
 * Message-related types for Discord API structures
 */
import type { User } from "./user";
import type { GuildMember } from "./guild";
import type { Channel } from "./channel";
import type { Role } from "./role";
/**
 * Message types
 */
export declare enum MessageType {
    DEFAULT = 0,
    RECIPIENT_ADD = 1,
    RECIPIENT_REMOVE = 2,
    CALL = 3,
    CHANNEL_NAME_CHANGE = 4,
    CHANNEL_ICON_CHANGE = 5,
    CHANNEL_PINNED_MESSAGE = 6,
    USER_JOIN = 7,
    GUILD_BOOST = 8,
    GUILD_BOOST_TIER_1 = 9,
    GUILD_BOOST_TIER_2 = 10,
    GUILD_BOOST_TIER_3 = 11,
    CHANNEL_FOLLOW_ADD = 12,
    GUILD_DISCOVERY_DISQUALIFIED = 14,
    GUILD_DISCOVERY_REQUALIFIED = 15,
    GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16,
    GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17,
    THREAD_CREATED = 18,
    REPLY = 19,
    CHAT_INPUT_COMMAND = 20,
    THREAD_STARTER_MESSAGE = 21,
    GUILD_INVITE_REMINDER = 22,
    CONTEXT_MENU_COMMAND = 23,
    AUTO_MODERATION_ACTION = 24,
    ROLE_SUBSCRIPTION_PURCHASE = 25,
    INTERACTION_PREMIUM_UPSELL = 26,
    STAGE_START = 27,
    STAGE_END = 28,
    STAGE_SPEAKER = 29,
    STAGE_TOPIC = 31,
    GUILD_APPLICATION_PREMIUM_SUBSCRIPTION = 32
}
/**
 * Represents a Discord message
 */
export interface Message {
    /** ID of the message */
    id: string;
    /** ID of the channel the message was sent in */
    channel_id: string;
    /** The author of this message (not guaranteed to be a valid user, see below) */
    author: User;
    /** Contents of the message */
    content: string;
    /** When this message was sent */
    timestamp: string;
    /** When this message was edited (or null if never) */
    edited_timestamp?: string | null;
    /** Whether this was a TTS message */
    tts: boolean;
    /** Whether this message mentions everyone */
    mention_everyone: boolean;
    /** Users specifically mentioned in the message */
    mentions: User[];
    /** Roles specifically mentioned in this message */
    mention_roles: string[];
    /** Channels specifically mentioned in this message */
    mention_channels?: ChannelMention[];
    /** Any attached files */
    attachments: Attachment[];
    /** Any embedded content */
    embeds: Embed[];
    /** Reactions to the message */
    reactions?: Reaction[];
    /** Used for validating a message was sent */
    nonce?: number | string;
    /** Whether this message is pinned */
    pinned: boolean;
    /** If the message is generated by a webhook, this is the webhook's id */
    webhook_id?: string;
    /** Type of message */
    type: MessageType;
    /** Sent with Rich Presence-related chat embeds */
    activity?: MessageActivity;
    /** Sent with Rich Presence-related chat embeds */
    application?: Application;
    /** If the message is an Interaction or application-owned webhook, this is the id of the application */
    application_id?: string;
    /** Data showing the source of a crosspost, channel follow add, pin, or reply message */
    message_reference?: MessageReference;
    /** Message flags combined as a bitfield */
    flags?: number;
    /** The message associated with the message_reference */
    referenced_message?: Message | null;
    /** Sent if the message is a response to an Interaction */
    interaction?: MessageInteraction;
    /** The thread that was started from this message, includes thread member object */
    thread?: Channel;
    /** Sent if the message contains components like buttons, action rows, or other interactive components */
    components?: MessageComponent[];
    /** Sent if the message contains stickers */
    sticker_items?: StickerItem[];
    /** Deprecated partial sticker objects */
    stickers?: Sticker[];
    /** A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread */
    position?: number;
    /** Data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message */
    role_subscription_data?: RoleSubscriptionData;
    /** Data for users, members, channels, and roles in the message's auto-populated select menus */
    resolved?: ResolvedData;
}
/**
 * Channel mention object
 */
export interface ChannelMention {
    /** ID of the channel */
    id: string;
    /** ID of the guild containing the channel */
    guild_id: string;
    /** The type of channel */
    type: number;
    /** The name of the channel */
    name: string;
}
/**
 * Attachment object
 */
export interface Attachment {
    /** Attachment ID */
    id: string;
    /** Name of file attached */
    filename: string;
    /** Description for the file (max 1024 characters) */
    description?: string;
    /** The attachment's media type */
    content_type?: string;
    /** Size of file in bytes */
    size: number;
    /** Source url of file */
    url: string;
    /** A proxied url of file */
    proxy_url: string;
    /** Height of file (if image) */
    height?: number | null;
    /** Width of file (if image) */
    width?: number | null;
    /** Whether this attachment is ephemeral */
    ephemeral?: boolean;
    /** The duration of the audio file (currently for voice messages) */
    duration_secs?: number;
    /** Base64 encoded bytearray representing a sampled waveform (currently for voice messages) */
    waveform?: string;
    /** Attachment flags combined as a bitfield */
    flags?: number;
}
/**
 * Embed object
 */
export interface Embed {
    /** Title of embed */
    title?: string;
    /** Type of embed (always "rich" for webhook embeds) */
    type?: string;
    /** Description of embed */
    description?: string;
    /** URL of embed */
    url?: string;
    /** Timestamp of embed content */
    timestamp?: string;
    /** Color code of the embed */
    color?: number;
    /** Footer information */
    footer?: EmbedFooter;
    /** Image information */
    image?: EmbedImage;
    /** Thumbnail information */
    thumbnail?: EmbedThumbnail;
    /** Video information */
    video?: EmbedVideo;
    /** Provider information */
    provider?: EmbedProvider;
    /** Author information */
    author?: EmbedAuthor;
    /** Fields information */
    fields?: EmbedField[];
}
/**
 * Embed footer object
 */
export interface EmbedFooter {
    /** Footer text */
    text: string;
    /** URL of footer icon (only supports http(s) and attachments) */
    icon_url?: string;
    /** A proxied url of footer icon */
    proxy_icon_url?: string;
}
/**
 * Embed image object
 */
export interface EmbedImage {
    /** Source url of image (only supports http(s) and attachments) */
    url: string;
    /** A proxied url of the image */
    proxy_url?: string;
    /** Height of image */
    height?: number;
    /** Width of image */
    width?: number;
}
/**
 * Embed thumbnail object
 */
export interface EmbedThumbnail {
    /** Source url of thumbnail (only supports http(s) and attachments) */
    url: string;
    /** A proxied url of the thumbnail */
    proxy_url?: string;
    /** Height of thumbnail */
    height?: number;
    /** Width of thumbnail */
    width?: number;
}
/**
 * Embed video object
 */
export interface EmbedVideo {
    /** Source url of video */
    url?: string;
    /** A proxied url of the video */
    proxy_url?: string;
    /** Height of video */
    height?: number;
    /** Width of video */
    width?: number;
}
/**
 * Embed provider object
 */
export interface EmbedProvider {
    /** Name of provider */
    name?: string;
    /** URL of provider */
    url?: string;
}
/**
 * Embed author object
 */
export interface EmbedAuthor {
    /** Name of author */
    name: string;
    /** URL of author (only supports http(s)) */
    url?: string;
    /** URL of author icon (only supports http(s) and attachments) */
    icon_url?: string;
    /** A proxied url of author icon */
    proxy_icon_url?: string;
}
/**
 * Embed field object
 */
export interface EmbedField {
    /** Name of the field */
    name: string;
    /** Value of the field */
    value: string;
    /** Whether or not this field should display inline */
    inline?: boolean;
}
/**
 * Reaction object
 */
export interface Reaction {
    /** Times this emoji has been used to react */
    count: number;
    /** Whether the current user reacted using this emoji */
    me: boolean;
    /** Emoji information */
    emoji: PartialEmoji;
}
/**
 * Partial emoji object
 */
export interface PartialEmoji {
    /** Emoji ID */
    id?: string | null;
    /** Emoji name */
    name?: string | null;
    /** Whether this emoji is animated */
    animated?: boolean;
}
/**
 * Message activity object
 */
export interface MessageActivity {
    /** Type of message activity */
    type: number;
    /** party_id from a Rich Presence event */
    party_id?: string;
}
/**
 * Application object
 */
export interface Application {
    /** The ID of the app */
    id: string;
    /** The name of the app */
    name: string;
    /** The icon hash of the app */
    icon?: string | null;
    /** The description of the app */
    description: string;
    /** An array of rpc origin urls, if rpc is enabled */
    rpc_origins?: string[];
    /** When false only app owner can join the app's bot to guilds */
    bot_public: boolean;
    /** When true the app's bot will only join upon completion of the full oauth2 code grant flow */
    bot_require_code_grant: boolean;
    /** The url of the app's terms of service */
    terms_of_service_url?: string;
    /** The url of the app's privacy policy */
    privacy_policy_url?: string;
    /** Partial user object containing info on the owner of the application */
    owner?: User;
    /** Hex encoded key for verification in interactions and the GameSDK's GetTicket */
    verify_key: string;
    /** The application's team */
    team?: Team | null;
    /** If this application is a game sold on Discord, this field will be the guild to which it has been linked */
    guild_id?: string;
    /** If this application is a game sold on Discord, this field will be the id of the "Game SKU" that is created, if exists */
    primary_sku_id?: string;
    /** If this application is a game sold on Discord, this field will be the URL slug that links to the store page */
    slug?: string;
    /** The application's default rich presence invite cover image hash */
    cover_image?: string;
    /** The application's public flags */
    flags?: number;
    /** An approximate count of the app's guild count */
    approximate_guild_count?: number;
    /** Array of redirect URIs for the app */
    redirect_uris?: string[];
    /** Interactions endpoint URL for the app */
    interactions_endpoint_url?: string;
    /** Role connection verification url for the app */
    role_connections_verification_url?: string;
    /** List of tags describing the content and functionality of the application */
    tags?: string[];
    /** Settings for the application's default in-app authorization link, if enabled */
    install_params?: InstallParams;
    /** The application's default custom authorization link, if enabled */
    custom_install_url?: string;
}
/**
 * Team object
 */
export interface Team {
    /** A hash of the image of the team's icon */
    icon?: string | null;
    /** The unique id of the team */
    id: string;
    /** The members of the team */
    members: TeamMember[];
    /** The name of the team */
    name: string;
    /** The user id of the current team owner */
    owner_user_id: string;
}
/**
 * Team member object
 */
export interface TeamMember {
    /** The user's membership state on the team */
    membership_state: number;
    /** Will always be ["*"] */
    permissions: string[];
    /** The id of the parent team of which they are a member */
    team_id: string;
    /** The avatar, discriminator, id, and username of the user */
    user: User;
}
/**
 * Install params object
 */
export interface InstallParams {
    /** The scopes to add the application to the server with */
    scopes: string[];
    /** The permissions to request for the bot role */
    permissions: string;
}
/**
 * Message reference object
 */
export interface MessageReference {
    /** ID of the originating message */
    message_id?: string;
    /** ID of the originating message's channel */
    channel_id?: string;
    /** ID of the originating message's guild */
    guild_id?: string;
    /** When sending, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true */
    fail_if_not_exists?: boolean;
}
/**
 * Message interaction object
 */
export interface MessageInteraction {
    /** ID of the interaction */
    id: string;
    /** Type of interaction */
    type: number;
    /** Name of the application command, including subcommands/subcommand groups */
    name: string;
    /** User who invoked the interaction */
    user: User;
    /** Member who invoked the interaction in the guild */
    member?: GuildMember;
}
/**
 * Message component object
 */
export interface MessageComponent {
    /** Component type */
    type: number;
    /** Developer-defined identifier for the component */
    custom_id?: string;
    /** Whether the component is disabled */
    disabled?: boolean;
    /** One of button styles */
    style?: number;
    /** Text that appears on the button */
    label?: string;
    /** Name, id, and animated */
    emoji?: PartialEmoji;
    /** URL for link-style buttons */
    url?: string;
    /** Options for select menus */
    options?: SelectOption[];
    /** List of channel types to include in the channel select component */
    channel_types?: number[];
    /** Placeholder text if nothing is selected */
    placeholder?: string;
    /** Minimum number of items that must be chosen */
    min_values?: number;
    /** Maximum number of items that can be chosen */
    max_values?: number;
    /** A list of child components */
    components?: MessageComponent[];
}
/**
 * Select option object
 */
export interface SelectOption {
    /** User-facing name of the option */
    label: string;
    /** Dev-defined value of the option */
    value: string;
    /** Additional description of the option */
    description?: string;
    /** ID, name, and animated */
    emoji?: PartialEmoji;
    /** Will show this option as selected by default */
    default?: boolean;
}
/**
 * Sticker item object
 */
export interface StickerItem {
    /** ID of the sticker */
    id: string;
    /** Name of the sticker */
    name: string;
    /** Type of sticker format */
    format_type: number;
}
/**
 * Sticker object
 */
export interface Sticker {
    /** ID of the sticker */
    id: string;
    /** For guild stickers, the Discord name of a unicode emoji representing the sticker's expression */
    name: string;
    /** Description of the sticker */
    description?: string | null;
    /** Autocomplete/suggestion tags for the sticker (max 200 characters) */
    tags: string;
    /** Type of sticker format */
    format_type: number;
    /** Whether this guild sticker can be used, may be false due to loss of Server Boosts */
    available?: boolean;
    /** ID of the guild that owns this sticker */
    guild_id?: string;
    /** The user that uploaded the guild sticker */
    user?: User;
    /** The standard sticker's sort order within its pack */
    sort_value?: number;
}
/**
 * Role subscription data object
 */
export interface RoleSubscriptionData {
    /** The id of the sku and listing that the user is subscribed to */
    role_subscription_listing_id: string;
    /** The name of the tier that the user is subscribed to */
    tier_name: string;
    /** The cumulative number of months that the user has been subscribed for */
    total_months_subscribed: number;
    /** Whether this notification is for a renewal rather than a new purchase */
    is_renewal: boolean;
}
/**
 * Resolved data object
 */
export interface ResolvedData {
    /** The IDs and User objects */
    users?: Record<string, User>;
    /** The IDs and partial Member objects */
    members?: Record<string, GuildMember>;
    /** The IDs and Role objects */
    roles?: Record<string, Role>;
    /** The IDs and partial Channel objects */
    channels?: Record<string, Channel>;
    /** The IDs and partial Message objects */
    messages?: Record<string, Message>;
    /** The IDs and attachment objects */
    attachments?: Record<string, Attachment>;
}
//# sourceMappingURL=message.d.ts.map